<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Clipper's Pixel Adventure</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }
    
    body {
      background: linear-gradient(to bottom, #5c94fc 0%, #7ba7fc 50%, #8fb4fc 100%);
      font-family: 'Press Start 2P', cursive;
      overflow: hidden;
      position: relative;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #gameContainer {
      width: 100%;
      max-width: 1024px;
      height: 100%;
      max-height: 576px;
      position: relative;
      background: #5c94fc;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
    }
    
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      image-rendering: pixelated;
      cursor: pointer;
    }
    
    #menu {
      position: absolute;
      inset: 0;
      background: linear-gradient(to bottom, #5c94fc 0%, #7ba7fc 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    
    #menu.hidden {
      display: none;
    }
    
    .title {
      color: white;
      font-size: 32px;
      margin-bottom: 20px;
      text-shadow: 3px 3px 0 #3d5a9f;
      animation: bounce 2s infinite;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    .subtitle {
      color: #ffd700;
      font-size: 12px;
      margin-bottom: 40px;
      text-shadow: 2px 2px 0 #3d5a9f;
    }
    
    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .menu-btn {
      background: linear-gradient(to bottom, #7fc97f 0%, #5fa55f 100%);
      color: white;
      border: 3px solid #3d7c3d;
      padding: 15px 30px;
      font-size: 14px;
      cursor: pointer;
      text-shadow: 1px 1px 0 #2d5c2d;
      box-shadow: 0 4px 0 #2d5c2d;
      transition: all 0.1s;
      font-family: 'Press Start 2P', cursive;
    }
    
    .menu-btn:hover {
      transform: translateY(2px);
      box-shadow: 0 2px 0 #2d5c2d;
    }
    
    .menu-btn:active {
      transform: translateY(4px);
      box-shadow: none;
    }
    
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 12px;
      text-shadow: 2px 2px 0 #000;
      z-index: 50;
    }
    
    .hud-item {
      margin-bottom: 10px;
    }
    
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 50;
    }
    
    .control-btn {
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.3);
      border: 3px solid rgba(255,255,255,0.5);
      border-radius: 10px;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    
    .control-btn:active {
      background: rgba(255,255,255,0.5);
    }
    
    @media (min-width: 768px) {
      #controls {
        display: none;
      }
    }
    
    #winScreen {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 200;
      color: white;
    }
    
    #winScreen.show {
      display: flex;
    }
    
    .win-title {
      font-size: 24px;
      margin-bottom: 20px;
      color: #ffd700;
      text-shadow: 3px 3px 0 #000;
    }
    
    .win-stats {
      font-size: 14px;
      margin-bottom: 30px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <div id="menu">
      <h1 class="title">CLIPPER RUN</h1>
      <p class="subtitle">Das Pixel-Abenteuer</p>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="startGame(0)">Level 1</button>
        <button class="menu-btn" onclick="startGame(1)">Level 2</button>
        <button class="menu-btn" onclick="startGame(2)">Level 3</button>
        <button class="menu-btn" onclick="startGame(3)">Level 4</button>
        <button class="menu-btn" onclick="startGame(4)">Level 5</button>
      </div>
    </div>
    
    <div id="hud" style="display: none;">
      <div class="hud-item">LEVEL: <span id="levelNum">1</span></div>
      <div class="hud-item">COINS: <span id="coins">0</span>/<span id="totalCoins">0</span></div>
      <div class="hud-item">LIVES: <span id="lives">3</span></div>
    </div>
    
    <div id="controls" style="display: none;">
      <div class="control-btn" id="leftBtn">◀</div>
      <div class="control-btn" id="jumpBtn">⬆</div>
      <div class="control-btn" id="rightBtn">▶</div>
    </div>
    
    <div id="winScreen">
      <h2 class="win-title">LEVEL COMPLETE!</h2>
      <p class="win-stats" id="winStats"></p>
      <button class="menu-btn" onclick="nextLevel()">NEXT LEVEL</button>
      <button class="menu-btn" onclick="showMenu()">MENU</button>
    </div>
  </div>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas resolution
    canvas.width = 1024;
    canvas.height = 576;
    
    // Disable smoothing for pixel art
    ctx.imageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    
    // Game variables
    let gameRunning = false;
    let currentLevel = 0;
    let animationId = null;
    
    // Level data
    const LEVELS = [
      {
        name: "Tutorial",
        map: [
          "                                                ",
          "                    *        *         *        ",
          "                                               G",
          "            ****        *        ****        ***",
          "       *           *********                    ",
          "    ****                          ****          ",
          " P                    E                         ",
          "################################################",
          "################################################"
        ]
      },
      {
        name: "Dangerous Path",
        map: [
          "                                                ",
          "         *                              *       ",
          "                 ***            ***             ",
          " P     *                E                      G",
          "###      ***                       ***       ###",
          "             ***     *      ***                 ",
          "                  *****                         ",
          "         E                    E                 ",
          "###############     ##############     #########"
        ]
      },
      {
        name: "Cave",
        map: [
          "################################################",
          "#              *            *         E        #",
          "#     ****                ****        ****     #",
          "#P          ****     *           E            G#",
          "###       *        *****              ****  ####",
          "#     ****                   *               ###",
          "#                  *      ****       ****      #",
          "#       E        *****                    E    #",
          "################################################"
        ]
      },
      {
        name: "Sky Islands",
        map: [
          "                                                ",
          "      *                           *          *  ",
          "   *****                *      ****         ** G",
          " P            ****       E                   ***",
          "###  *     *         *****       *      ***    #",
          "     ***   ***                   ***           #",
          "                ****      *  ***          E    #",
          "    E            *     *****     *   ***       #",
          "#######  ###############      ##########  ######"
        ]
      },
      {
        name: "Final Challenge",
        map: [
          "                                                ",
          "   *         **       *         **        *     ",
          " ****    E    **      ****      **    *    *** G",
          " **        ** **  *   ****      ** ****    ** ##",
          " **P  *    ** ****    ****   E  ** **      ** ##",
          " ** ****   **    **   ****  **  ** **      ** ##",
          " **        **    **  * ****  ** ** **      ** ##",
          " **    E   **    ** **** **  ** ** **      ** ##",
          "################################ ###############"
        ]
      }
    ];
    
    // Tile size
    const TILE = 32;
    
    // Game objects
    let player = null;
    let coins = [];
    let enemies = [];
    let particles = [];
    let camera = { x: 0, y: 0 };
    let keys = {};
    let touches = { left: false, right: false, jump: false };
    
    // Player properties
    const PLAYER_SPEED = 250;
    const JUMP_FORCE = 500;
    const GRAVITY = 1000;
    
    // Initialize player
    function createPlayer(x, y) {
      return {
        x: x * TILE,
        y: y * TILE,
        vx: 0,
        vy: 0,
        width: 28,
        height: 36,
        onGround: false,
        facing: 1,
        lives: 3,
        coins: 0,
        invulnerable: 0,
        animFrame: 0,
        animTimer: 0
      };
    }
    
    // Draw Clipper character (based on the PNG design)
    function drawClipperCharacter(x, y, facing, animFrame) {
      ctx.save();
      ctx.translate(x, y);
      if (facing < 0) {
        ctx.scale(-1, 1);
      }
      
      // Main body (light gray/beige like the PNG)
      ctx.fillStyle = '#d9dbdf';
      ctx.fillRect(-12, -18, 24, 32);
      
      // Top metal part (darker gray)
      ctx.fillStyle = '#8a8f97';
      ctx.fillRect(-12, -18, 24, 8);
      
      // Wheel on top
      ctx.fillStyle = '#5a5f67';
      ctx.beginPath();
      ctx.arc(8, -14, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Wheel ridges
      ctx.strokeStyle = '#3a3f47';
      ctx.lineWidth = 1;
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(8 + Math.cos(angle) * 3, -14 + Math.sin(angle) * 3);
        ctx.lineTo(8 + Math.cos(angle) * 5, -14 + Math.sin(angle) * 5);
        ctx.stroke();
      }
      
      // CLIPPER text box
      ctx.fillStyle = '#2b2f37';
      ctx.fillRect(-10, -8, 20, 10);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 6px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('CLIPPER', 0, -2);
      
      // Face - eyes (friendly look like in PNG)
      ctx.fillStyle = '#1a1d23';
      // Left eye
      ctx.beginPath();
      ctx.arc(-5, 2, 3, 0, Math.PI * 2);
      ctx.fill();
      // Right eye  
      ctx.beginPath();
      ctx.arc(5, 2, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Eye pupils (white dots for friendly look)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-5, 1, 2, 2);
      ctx.fillRect(5, 1, 2, 2);
      
      // Smile
      ctx.strokeStyle = '#1a1d23';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(0, 4, 6, 0.2 * Math.PI, 0.8 * Math.PI);
      ctx.stroke();
      
      // Arms (dark like in PNG)
      ctx.fillStyle = '#2b2f37';
      const armOffset = Math.sin(animFrame * 0.3) * 2;
      // Left arm
      ctx.fillRect(-16, 0 + armOffset, 5, 3);
      ctx.fillRect(-16, 0 + armOffset, 3, 8);
      // Right arm (pointing)
      ctx.fillRect(11, 0 - armOffset, 5, 3);
      ctx.fillRect(13, 0 - armOffset, 3, 8);
      
      // Legs (dark like arms)
      const legOffset = Math.sin(animFrame * 0.4) * 3;
      ctx.fillRect(-7 + legOffset, 14, 4, 6);
      ctx.fillRect(3 - legOffset, 14, 4, 6);
      
      // Shoes (lighter like in PNG)
      ctx.fillStyle = '#e5dfd4';
      ctx.fillRect(-8 + legOffset, 18, 6, 4);
      ctx.fillRect(2 - legOffset, 18, 6, 4);
      
      // Body highlights
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillRect(-11, -17, 3, 20);
      
      // Metal shine on top
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.fillRect(-11, -17, 10, 2);
      
      ctx.restore();
    }
    
    // Draw Enemy character (based on the "LIGHTER" PNG - dark/evil version)
    function drawEnemyCharacter(x, y, animFrame) {
      ctx.save();
      ctx.translate(x, y);
      
      // Main body (dark gray)
      ctx.fillStyle = '#4a4f57';
      ctx.fillRect(-12, -18, 24, 32);
      
      // Top metal part (black)
      ctx.fillStyle = '#1a1f27';
      ctx.fillRect(-12, -18, 24, 8);
      
      // Evil wheel on top (red accent)
      ctx.fillStyle = '#8b1a1a';
      ctx.beginPath();
      ctx.arc(8, -14, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Wheel spikes (menacing)
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 2;
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(8, -14);
        ctx.lineTo(8 + Math.cos(angle) * 6, -14 + Math.sin(angle) * 6);
        ctx.stroke();
      }
      
      // LIGHTER text box
      ctx.fillStyle = '#1a1f27';
      ctx.fillRect(-10, -8, 20, 10);
      ctx.fillStyle = '#ff6b6b';
      ctx.font = 'bold 5px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('LIGHTER', 0, -2);
      
      // Evil face - angry eyes (red like in PNG)
      ctx.fillStyle = '#ff0000';
      // Left eye (angular/evil)
      ctx.beginPath();
      ctx.moveTo(-8, 0);
      ctx.lineTo(-4, 3);
      ctx.lineTo(-8, 6);
      ctx.lineTo(-10, 3);
      ctx.fill();
      // Right eye
      ctx.beginPath();
      ctx.moveTo(8, 0);
      ctx.lineTo(4, 3);
      ctx.lineTo(8, 6);
      ctx.lineTo(10, 3);
      ctx.fill();
      
      // Evil grin (white teeth)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-6, 8, 2, 3);
      ctx.fillRect(-3, 8, 2, 3);
      ctx.fillRect(0, 8, 2, 3);
      ctx.fillRect(3, 8, 2, 3);
      ctx.fillRect(6, 8, 2, 3);
      
      // Mouth background
      ctx.fillStyle = '#1a1f27';
      ctx.fillRect(-7, 7, 14, 5);
      // Teeth on top
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-6, 8, 2, 2);
      ctx.fillRect(-3, 9, 2, 2);
      ctx.fillRect(0, 8, 2, 2);
      ctx.fillRect(3, 9, 2, 2);
      ctx.fillRect(5, 8, 2, 2);
      
      // Arms (black, menacing pose)
      ctx.fillStyle = '#1a1f27';
      const wobble = Math.sin(animFrame * 0.2) * 2;
      // Left arm (raised fist)
      ctx.save();
      ctx.rotate(-0.3 + wobble * 0.05);
      ctx.fillRect(-16, -2, 5, 3);
      ctx.fillRect(-16, -2, 3, 8);
      // Fist
      ctx.fillRect(-17, -4, 5, 5);
      ctx.restore();
      
      // Right arm (raised fist)
      ctx.save();
      ctx.rotate(0.3 - wobble * 0.05);
      ctx.fillRect(11, -2, 5, 3);
      ctx.fillRect(13, -2, 3, 8);
      // Fist
      ctx.fillRect(12, -4, 5, 5);
      ctx.restore();
      
      // Legs (stomping animation)
      const stomp = Math.abs(Math.sin(animFrame * 0.3)) * 2;
      ctx.fillRect(-7, 14 - stomp, 4, 6 + stomp);
      ctx.fillRect(3, 14 + stomp, 4, 6 - stomp);
      
      // Evil shoes (dark)
      ctx.fillStyle = '#2a2f37';
      ctx.fillRect(-8, 18, 6, 4);
      ctx.fillRect(2, 18, 6, 4);
      
      // Dark aura effect
      ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
      ctx.beginPath();
      ctx.arc(0, 0, 25 + Math.sin(animFrame * 0.1) * 3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    
    // Draw pixel-perfect ground tiles
    function drawGroundTile(x, y) {
      // Base dirt
      ctx.fillStyle = '#8b6239';
      ctx.fillRect(x, y, TILE, TILE);
      
      // Grass on top
      ctx.fillStyle = '#52d053';
      ctx.fillRect(x, y, TILE, 8);
      
      // Grass blades
      ctx.fillStyle = '#42b543';
      for (let i = 0; i < TILE; i += 4) {
        const height = 3 + Math.sin(i * 0.5) * 2;
        ctx.fillRect(x + i, y - height, 2, height + 3);
      }
      
      // Dirt texture
      ctx.fillStyle = '#6e4e2e';
      ctx.fillRect(x + 4, y + 12, 3, 2);
      ctx.fillRect(x + 14, y + 18, 2, 3);
      ctx.fillRect(x + 24, y + 14, 3, 2);
      ctx.fillRect(x + 8, y + 24, 2, 2);
      
      // Highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.fillRect(x, y, TILE, 2);
    }
    
    // Draw stone tile
    function drawStoneTile(x, y) {
      ctx.fillStyle = '#6b7588';
      ctx.fillRect(x, y, TILE, TILE);
      
      // Stone texture
      ctx.fillStyle = '#525866';
      ctx.fillRect(x + 2, y + 2, 10, 8);
      ctx.fillRect(x + 18, y + 14, 8, 6);
      ctx.fillRect(x + 6, y + 20, 12, 7);
      
      // Cracks
      ctx.strokeStyle = '#3a3f47';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + 8, y + 4);
      ctx.lineTo(x + 12, y + 12);
      ctx.lineTo(x + 10, y + 20);
      ctx.stroke();
      
      // Highlights
      ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.fillRect(x, y, TILE, 2);
      ctx.fillRect(x, y, 2, TILE);
    }
    
    // Draw coin
    function drawCoin(x, y, animFrame) {
      const bob = Math.sin(animFrame * 0.1) * 3;
      
      // Shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(x, y + 12, 8, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Coin
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.arc(x, y + bob, 10, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner circle
      ctx.fillStyle = '#ffed4e';
      ctx.beginPath();
      ctx.arc(x, y + bob, 7, 0, Math.PI * 2);
      ctx.fill();
      
      // Star symbol
      ctx.fillStyle = '#ffd700';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('★', x, y + bob);
      
      // Shine
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(x - 3, y - 3 + bob, 3, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw flag/goal
    function drawGoal(x, y, animFrame) {
      // Pole
      ctx.fillStyle = '#8a8f97';
      ctx.fillRect(x + 28, y, 4, TILE);
      
      // Flag
      const wave = Math.sin(animFrame * 0.05) * 2;
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.moveTo(x + 28, y + 4);
      ctx.quadraticCurveTo(x + 16 + wave, y + 8, x + 28, y + 12);
      ctx.lineTo(x + 28, y + 4);
      ctx.fill();
      
      // Goal platform
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(x + 4, y + 24, 24, 8);
      ctx.fillStyle = '#ffed4e';
      ctx.fillRect(x + 4, y + 24, 24, 3);
    }
    
    // Particle system
    function createParticle(x, y, vx, vy, color, life) {
      particles.push({ x, y, vx, vy, color, life, maxLife: life });
    }
    
    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 500 * dt; // gravity
        p.life -= dt;
        
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    
    function drawParticles() {
      particles.forEach(p => {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;
    }
    
    // Input handling
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === 'Escape') showMenu();
    });
    
    document.addEventListener('keyup', e => {
      keys[e.key] = false;
    });
    
    // Touch controls
    function setupTouchControls() {
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      const jumpBtn = document.getElementById('jumpBtn');
      
      const addTouchEvents = (btn, action) => {
        btn.addEventListener('touchstart', e => {
          e.preventDefault();
          touches[action] = true;
        });
        btn.addEventListener('touchend', e => {
          e.preventDefault();
          touches[action] = false;
        });
        btn.addEventListener('mousedown', () => touches[action] = true);
        btn.addEventListener('mouseup', () => touches[action] = false);
      };
      
      addTouchEvents(leftBtn, 'left');
      addTouchEvents(rightBtn, 'right');
      addTouchEvents(jumpBtn, 'jump');
    }
    
    // Load level
    function loadLevel(levelIndex) {
      const level = LEVELS[levelIndex];
      coins = [];
      enemies = [];
      particles = [];
      
      // Parse level
      for (let y = 0; y < level.map.length; y++) {
        for (let x = 0; x < level.map[y].length; x++) {
          const char = level.map[y][x];
          const px = x * TILE + TILE/2;
          const py = y * TILE + TILE/2;
          
          switch(char) {
            case 'P':
              player = createPlayer(x, y);
              break;
            case '*':
              coins.push({ x: px, y: py, collected: false });
              break;
            case 'E':
              enemies.push({ 
                x: px, 
                y: py, 
                vx: 50, 
                startX: px,
                alive: true,
                animFrame: Math.random() * Math.PI * 2
              });
              break;
          }
        }
      }
      
      // Update HUD
      document.getElementById('levelNum').textContent = levelIndex + 1;
      document.getElementById('totalCoins').textContent = coins.length;
      document.getElementById('coins').textContent = 0;
      document.getElementById('lives').textContent = player.lives;
    }
    
    // Collision detection
    function getTileAt(x, y) {
      const level = LEVELS[currentLevel];
      const tx = Math.floor(x / TILE);
      const ty = Math.floor(y / TILE);
      
      if (ty < 0 || ty >= level.map.length || tx < 0 || tx >= level.map[0].length) {
        return ' ';
      }
      
      return level.map[ty][tx];
    }
    
    function isColliding(x, y, w, h) {
      const left = Math.floor(x / TILE);
      const right = Math.floor((x + w) / TILE);
      const top = Math.floor(y / TILE);
      const bottom = Math.floor((y + h) / TILE);
      
      for (let ty = top; ty <= bottom; ty++) {
        for (let tx = left; tx <= right; tx++) {
          const tile = getTileAt(tx * TILE, ty * TILE);
          if (tile === '#' || tile === '@') {
            return true;
          }
        }
      }
      
      return false;
    }
    
    // Game update
    function update(dt) {
      if (!gameRunning || !player) return;
      
      // Player input
      const left = keys['ArrowLeft'] || keys['a'] || keys['A'] || touches.left;
      const right = keys['ArrowRight'] || keys['d'] || keys['D'] || touches.right;
      const jump = keys[' '] || keys['ArrowUp'] || keys['w'] || keys['W'] || touches.jump;
      
      // Horizontal movement
      if (left) {
        player.vx = -PLAYER_SPEED;
        player.facing = -1;
      } else if (right) {
        player.vx = PLAYER_SPEED;
        player.facing = 1;
      } else {
        player.vx *= 0.8;
      }
      
      // Jump
      if (jump && player.onGround) {
        player.vy = -JUMP_FORCE;
        player.onGround = false;
        
        // Jump particles
        for (let i = 0; i < 5; i++) {
          createParticle(
            player.x + player.width/2,
            player.y + player.height,
            (Math.random() - 0.5) * 100,
            -Math.random() * 50,
            '#8a8f97',
            0.3
          );
        }
      }
      
      // Gravity
      if (!player.onGround) {
        player.vy += GRAVITY * dt;
        if (player.vy > 600) player.vy = 600;
      }
      
      // Move horizontally
      const newX = player.x + player.vx * dt;
      if (!isColliding(newX, player.y, player.width, player.height)) {
        player.x = newX;
      }
      
      // Move vertically
      const newY = player.y + player.vy * dt;
      if (!isColliding(player.x, newY, player.width, player.height)) {
        player.y = newY;
        player.onGround = false;
      } else {
        if (player.vy > 0) {
          // Landing
          player.onGround = true;
          // Snap to ground
          while (!isColliding(player.x, player.y + 1, player.width, player.height)) {
            player.y++;
          }
        }
        player.vy = 0;
      }
      
      // Update animation
      player.animTimer += dt;
      if (player.animTimer > 0.1) {
        player.animTimer = 0;
        player.animFrame++;
      }
      
      // Collect coins
      coins.forEach(coin => {
        if (coin.collected) return;
        
        const dx = Math.abs(player.x + player.width/2 - coin.x);
        const dy = Math.abs(player.y + player.height/2 - coin.y);
        
        if (dx < 20 && dy < 20) {
          coin.collected = true;
          player.coins++;
          document.getElementById('coins').textContent = player.coins;
          
          // Coin particles
          for (let i = 0; i < 8; i++) {
            createParticle(
              coin.x,
              coin.y,
              (Math.random() - 0.5) * 200,
              -Math.random() * 200,
              '#ffd700',
              0.5
            );
          }
        }
      });
      
      // Update enemies
      enemies.forEach(enemy => {
        if (!enemy.alive) return;
        
        enemy.animFrame += dt * 5;
        
        // Patrol movement
        enemy.x += enemy.vx * dt;
        if (Math.abs(enemy.x - enemy.startX) > 80) {
          enemy.vx = -enemy.vx;
        }
        
        // Check collision with player
        const dx = Math.abs(player.x + player.width/2 - enemy.x);
        const dy = Math.abs(player.y + player.height/2 - enemy.y);
        
        if (dx < 25 && dy < 30) {
          if (player.vy > 100 && player.y < enemy.y) {
            // Stomp enemy
            enemy.alive = false;
            player.vy = -300;
            
            // Defeat particles
            for (let i = 0; i < 10; i++) {
              createParticle(
                enemy.x,
                enemy.y,
                (Math.random() - 0.5) * 300,
                -Math.random() * 300,
                '#ff6b6b',
                0.6
              );
            }
          } else if (player.invulnerable <= 0) {
            // Damage player
            player.lives--;
            player.invulnerable = 2;
            document.getElementById('lives').textContent = player.lives;
            
            // Knockback
            player.vx = (player.x < enemy.x ? -1 : 1) * 300;
            player.vy = -200;
            
            if (player.lives <= 0) {
              gameOver();
            }
          }
        }
      });
      
      // Check goal
      const goalTile = getTileAt(player.x + player.width/2, player.y + player.height/2);
      if (goalTile === 'G' && player.coins === coins.length) {
        levelComplete();
      }
      
      // Fall death
      if (player.y > canvas.height + 100) {
        player.lives--;
        document.getElementById('lives').textContent = player.lives;
        if (player.lives <= 0) {
          gameOver();
        } else {
          loadLevel(currentLevel);
        }
      }
      
      // Update invulnerability
      if (player.invulnerable > 0) {
        player.invulnerable -= dt;
      }
      
      // Update particles
      updateParticles(dt);
      
      // Update camera
      camera.x = player.x - canvas.width/2;
      camera.y = player.y - canvas.height/2;
      
      // Clamp camera
      const level = LEVELS[currentLevel];
      const maxX = level.map[0].length * TILE - canvas.width;
      const maxY = level.map.length * TILE - canvas.height;
      camera.x = Math.max(0, Math.min(camera.x, maxX));
      camera.y = Math.max(0, Math.min(camera.y, maxY));
    }
    
    // Render
    function render() {
      // Clear
      ctx.fillStyle = '#5c94fc';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Background clouds
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillRect(100 - camera.x * 0.3, 50, 120, 40);
      ctx.fillRect(300 - camera.x * 0.3, 80, 150, 50);
      ctx.fillRect(500 - camera.x * 0.3, 40, 100, 35);
      
      ctx.save();
      ctx.translate(-camera.x, -camera.y);
      
      // Draw level
      const level = LEVELS[currentLevel];
      for (let y = 0; y < level.map.length; y++) {
        for (let x = 0; x < level.map[y].length; x++) {
          const char = level.map[y][x];
          const px = x * TILE;
          const py = y * TILE;
          
          switch(char) {
            case '#':
              drawGroundTile(px, py);
              break;
            case '@':
              drawStoneTile(px, py);
              break;
            case 'G':
              drawGoal(px, py, player.animFrame);
              break;
          }
        }
      }
      
      // Draw coins
      coins.forEach(coin => {
        if (!coin.collected) {
          drawCoin(coin.x, coin.y, player.animFrame);
        }
      });
      
      // Draw enemies
      enemies.forEach(enemy => {
        if (enemy.alive) {
          drawEnemyCharacter(enemy.x, enemy.y, enemy.animFrame);
        }
      });
      
      // Draw particles
      drawParticles();
      
      // Draw player (with invulnerability flash)
      if (!player.invulnerable || Math.floor(player.invulnerable * 10) % 2 === 0) {
        drawClipperCharacter(
          player.x + player.width/2,
          player.y + player.height/2,
          player.facing,
          player.animFrame
        );
      }
      
      ctx.restore();
    }
    
    // Game loop
    let lastTime = 0;
    function gameLoop(currentTime) {
      const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
      lastTime = currentTime;
      
      update(dt);
      render();
      
      if (gameRunning) {
        animationId = requestAnimationFrame(gameLoop);
      }
    }
    
    // Start game
    function startGame(levelIndex) {
      currentLevel = levelIndex;
      loadLevel(levelIndex);
      
      document.getElementById('menu').classList.add('hidden');
      document.getElementById('hud').style.display = 'block';
      
      // Show touch controls on mobile
      if (window.innerWidth < 768) {
        document.getElementById('controls').style.display = 'flex';
      }
      
      gameRunning = true;
      lastTime = performance.now();
      gameLoop(performance.now());
    }
    
    // Show menu
    function showMenu() {
      gameRunning = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      
      document.getElementById('menu').classList.remove('hidden');
      document.getElementById('hud').style.display = 'none';
      document.getElementById('controls').style.display = 'none';
      document.getElementById('winScreen').classList.remove('show');
    }
    
    // Level complete
    function levelComplete() {
      gameRunning = false;
      
      const stats = `Coins: ${player.coins}/${coins.length} | Lives: ${player.lives}`;
      document.getElementById('winStats').textContent = stats;
      document.getElementById('winScreen').classList.add('show');
    }
    
    // Next level
    function nextLevel() {
      currentLevel++;
      if (currentLevel >= LEVELS.length) {
        currentLevel = 0;
      }
      
      document.getElementById('winScreen').classList.remove('show');
      startGame(currentLevel);
    }
    
    // Game over
    function gameOver() {
      gameRunning = false;
      setTimeout(() => {
        showMenu();
      }, 2000);
    }
    
    // Initialize
    setupTouchControls();
  </script>
</body>
</html>
