<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Clipper Run â€“ Retro Platformer</title>
  <style>
    :root{
      --bg-0:#0c0f1c; --bg-1:#17213d; --bg-2:#223056; --bg-3:#2e4271;
      --ui:#0b1220; --ui-b:#203056; --fg:#eef3ff;
      --grass:#85f089; --dirt:#5a3c28; --stone:#6b7280; --platform:#7b8494;
      --clipper:#d9dbdf; --clipper-dark:#8a8f97; --clipper-accent:#2b2f37;
      --player:#7aa2ff; --enemy:#ff6b6b; --coin:#ffd166; --goal:#22c55e; --flag:#f97316;
      --paper:#e5dfd4; --spike:#dc2626;
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{height:100%;margin:0;background:var(--bg-0);color:var(--fg);
      font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;
      overflow:hidden;touch-action:none}
    #wrap{display:flex;flex-direction:column;height:100%;gap:.5rem;padding:.5rem}
    canvas{flex:1;width:100%;border-radius:12px;border:1px solid var(--ui-b);
      background:linear-gradient(180deg,var(--bg-3),var(--bg-2) 40%,var(--bg-1) 70%,var(--bg-0));
      box-shadow:0 20px 50px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.04);
      image-rendering:pixelated;image-rendering:crisp-edges;touch-action:none}
    .hud{display:flex;gap:.4rem;align-items:center;justify-content:center;flex-wrap:wrap;padding:0 .25rem}
    .pill{background:var(--ui);border:1px solid var(--ui-b);color:var(--fg);padding:.3rem .5rem;
      border-radius:999px;font-size:.85rem;white-space:nowrap}
    .btn{cursor:pointer;user-select:none;transition:all .15s}
    .btn:active{transform:scale(.95);opacity:.8}
    .controls{display:flex;gap:.5rem;justify-content:center;padding:.25rem}
    .controls button{background:#0b1220;color:var(--fg);border:1px solid #1e293b;border-radius:12px;
      padding:.7rem 1rem;min-width:3.5rem;font-size:1.1rem;cursor:pointer;user-select:none;
      transition:all .15s;touch-action:none}
    .controls button:active{transform:scale(.92);background:#1e293b}
    #menu{position:fixed;inset:0;background:rgba(12,15,28,.95);display:flex;align-items:center;
      justify-content:center;z-index:100;flex-direction:column;gap:1.5rem}
    #menu.hidden{display:none}
    .menu-title{font-size:2.5rem;font-weight:800;color:var(--coin);text-shadow:2px 2px 0 var(--bg-1)}
    .menu-btns{display:flex;flex-direction:column;gap:.8rem}
    .menu-btn{background:var(--ui);border:2px solid var(--ui-b);color:var(--fg);padding:.8rem 2rem;
      border-radius:12px;font-size:1.2rem;cursor:pointer;transition:all .2s;min-width:200px;text-align:center}
    .menu-btn:hover{background:var(--ui-b);transform:translateY(-2px)}
    .menu-btn:active{transform:translateY(0)}
    .level-info{color:var(--grass);font-size:.9rem;margin-top:.5rem}
  </style>
</head>
<body>
  <div id="menu">
    <div class="menu-title">ðŸŽ® CLIPPER RUN</div>
    <div class="menu-btns" id="levelSelect"></div>
    <div class="level-info">Sammle alle MÃ¼nzen und erreiche das Ziel!</div>
  </div>
  <div id="wrap" style="display:none">
    <canvas id="game" aria-label="Clipper Run Game"></canvas>
    <div class="hud">
      <span class="pill">Level: <b id="levelNum">1</b></span>
      <span class="pill">MÃ¼nzen: <b id="coins">0</b>/<span id="coinmax">0</span></span>
      <span class="pill">Leben: <b id="lives">3</b></span>
      <span class="pill btn" id="restart">ðŸ”„ Neustart</span>
      <span class="pill btn" id="menuBtn">ðŸ“‹ MenÃ¼</span>
    </div>
    <div class="controls">
      <button id="left">â—€</button>
      <button id="jump">â¬†</button>
      <button id="right">â–¶</button>
    </div>
  </div>
<script>
(() => {
  // ===== LEVELS =====
  const LEVELS = [
    {
      name: "Level 1: Tutorial Valley",
      data: [
        "................................................................................................",
        ".......................*....................*.................*.................................",
        "..........................................................E.........................*............",
        "...............@@@@...............*..................@@@@@@@..................@@@@@.............",
        "..........*..................@@@@@@@.............................................................",
        "......@@@@@@.........................@@@@@@..................*...............@@@@@@.............",
        "..P.............................*....................E..................*....................G..",
        "######################....###############....#####################....##########################",
        "######################....###############....#####################....##########################"
      ]
    },
    {
      name: "Level 2: Dangerous Heights",
      data: [
        "................................................................................................",
        "...........*.........................................................................*..........",
        "..........................@@@@....................*.............................................",
        "..P......*......................................E.......................*.......................",
        "###........@@@@..............................@@@@@@@.....................@@@@@..................",
        "..................@@@@..........*.....................................................*........",
        ".............................@@@@@@..........*.................@@@@@@...............@@@@@.......",
        "..........E...............................................E.................................G...",
        "##################....################....#########################....#########################"
      ]
    },
    {
      name: "Level 3: Cave Explorer",
      data: [
        "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@",
        "@@.......................*..........................*...........E..............................@@",
        "@@.....@@@@.........................................@@@@@....................@@@@...............@@",
        "@@P................@@@@.......*.................E..................*..........................G@@",
        "@@@@..........*.................@@@@@@@................................@@@@@...........@@@@@@@@@",
        "@@.......@@@@@...........................@@@@...............*.............................@@@@@@",
        "@@..................................*...........@@@@@..................@@@@....E...............@@",
        "@@........E....................@@@@@@...............................*.......................@@@@",
        "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
      ]
    },
    {
      name: "Level 4: Sky Islands",
      data: [
        "................................................................................................",
        ".............*..............................................................................*...",
        "......@@@@@@@.........................................*.......@@@@@@........................@@..",
        "..P.........................@@@@@@.............E..............................................G.",
        "####.....*.............*...................@@@@@@@................*.............@@@@@.........##",
        "........@@@@@.....@@@@@...............................................@@@@@..................###",
        "............................@@@@@@..............*.......@@@@...........................E.......#",
        ".....E.......................*.........@@@@@@@...........*.................@@@@@...............#",
        "##########....########################.....................#################...........##########"
      ]
    },
    {
      name: "Level 5: The Final Challenge",
      data: [
        "................................................................................................",
        ".....*....................@@..................*...................@@...............*............",
        "..@@@@@...........E........@@..................@@@@@@............@@..........*......@@@@........",
        "..@@...............@@......@@..*...............@@..@@............@@......@@@@@......@@.@@.......",
        "..@@.P....*........@@......@@@@@@..............@@..@@...E........@@......@@.........@@..@@....G.",
        "..@@....@@@@@......@@..........@@..............@@..@@....@@......@@......@@.........@@..@@...###",
        "..@@...............@@..........@@...*..........@@..@@....@@......@@......@@.........@@..@@..####",
        "..@@........E......@@..........@@.@@@@@........@@..@@....@@...E..@@......@@.........@@..@@.#####",
        "################################################################################..##############"
      ]
    }
  ];

  // ===== CONFIG =====
  const canvas = document.getElementById('game');
  const cx = canvas.getContext('2d');
  const HUD = {
    coins: document.getElementById('coins'),
    coinmax: document.getElementById('coinmax'),
    lives: document.getElementById('lives'),
    levelNum: document.getElementById('levelNum')
  };
  const BTN = {
    restart: document.getElementById('restart'),
    menuBtn: document.getElementById('menuBtn'),
    left: document.getElementById('left'),
    right: document.getElementById('right'),
    jump: document.getElementById('jump')
  };
  const menu = document.getElementById('menu');
  const wrap = document.getElementById('wrap');

  // Pixel grid
  const TILE = 32;
  // Physics
  const GRAVITY = 2200, MAX_FALL = 1600;
  const RUN_SPEED = 340, ACCEL_GROUND = 2600, ACCEL_AIR = 1700, FRICTION = 2400;
  const JUMP_VEL = 840, COYOTE = 0.10, JUMP_BUFFER = 0.12, CAMERA_LERP = 0.14;
  const SOLID = new Set(["#","@"]);

  let currentLevel = 0;
  let LEVEL, ROWS, COLS, world;
  let coins, enemies, playerStart, player, camera;
  let keys = new Set();
  let mLeft=false, mRight=false, mJump=false;
  let bannerT=0, bannerMsg='';
  let particles=[];
  let gameRunning = false;

  // ===== MENU =====
  function initMenu(){
    const levelSelect = document.getElementById('levelSelect');
    levelSelect.innerHTML = '';
    LEVELS.forEach((lvl, i) => {
      const btn = document.createElement('div');
      btn.className = 'menu-btn';
      btn.textContent = lvl.name;
      btn.onclick = () => startLevel(i);
      levelSelect.appendChild(btn);
    });
  }

  function showMenu(){
    menu.classList.remove('hidden');
    wrap.style.display = 'none';
    gameRunning = false;
  }

  function hideMenu(){
    menu.classList.add('hidden');
    wrap.style.display = 'flex';
    gameRunning = true;
  }

  function startLevel(levelIndex){
    currentLevel = levelIndex;
    loadLevel();
    hideMenu();
    resizeCanvas();
  }

  // ===== LEVEL LOADING =====
  function loadLevel(){
    LEVEL = LEVELS[currentLevel].data;
    ROWS = LEVEL.length;
    COLS = LEVEL[0].length;
    world = { w: COLS*TILE, h: ROWS*TILE };

    coins = [];
    enemies = [];
    playerStart = findChar('P') || {x:1, y:ROWS-2};

    for(let y=0; y<ROWS; y++){
      for(let x=0; x<COLS; x++){
        const c = LEVEL[y][x];
        const wx = (x+0.5)*TILE, wy = (y+0.5)*TILE;
        if(c==='*') coins.push({x:wx, y:wy, r:11, alive:true, t:Math.random()*6});
        if(c==='E') enemies.push({x:wx, y:wy, vx:(Math.random()>0.5?1:-1)*90, w:26, h:30, alive:true});
      }
    }

    player = {
      x: (playerStart.x+0.2)*TILE,
      y: (playerStart.y-0.25)*TILE,
      w: 22, h: 36,
      vx: 0, vy: 0,
      onGround: false,
      coyote: 0, jumpBuf: 0,
      lives: 3, inv: 0,
      coins: 0, anim: 0
    };

    camera = { x: 0, y: 0 };
    particles = [];
    bannerT = 0;
    bannerMsg = '';

    HUD.levelNum.textContent = currentLevel + 1;
    HUD.coinmax.textContent = coins.length;
    HUD.coins.textContent = 0;
    HUD.lives.textContent = player.lives;
  }

  function reset(){
    loadLevel();
  }

  function nextLevel(){
    if(currentLevel < LEVELS.length - 1){
      showBanner('Level geschafft! Weiter zu Level ' + (currentLevel + 2));
      setTimeout(() => {
        currentLevel++;
        loadLevel();
      }, 2000);
    } else {
      showBanner('ðŸŽ‰ Alle Level geschafft! Du bist ein Meister!');
      setTimeout(showMenu, 3000);
    }
  }

  // ===== HELPERS =====
  const grid = (x) => Math.floor(x/TILE);
  const charAt = (gx,gy) => (gy<0||gy>=ROWS||gx<0||gx>=COLS) ? '.' : LEVEL[gy][gx];
  const solidAtWorld = (wx,wy) => SOLID.has(charAt(grid(wx), grid(wy)));
  function findChar(ch){
    for(let y=0; y<ROWS; y++){
      const x = LEVEL[y].indexOf(ch);
      if(x !== -1) return {x, y};
    }
    return null;
  }

  function getSolidTilesInAABB(minX,minY,maxX,maxY){
    const tiles = [];
    const gminX = Math.floor(minX/TILE), gmaxX = Math.floor((maxX-0.001)/TILE);
    const gminY = Math.floor(minY/TILE), gmaxY = Math.floor((maxY-0.001)/TILE);
    for(let gy=gminY; gy<=gmaxY; gy++){
      for(let gx=gminX; gx<=gmaxX; gx++){
        const c = charAt(gx, gy);
        if(SOLID.has(c)) tiles.push({gx, gy});
      }
    }
    return tiles;
  }

  function moveAndCollide(e, dx, dy){
    if(dx !== 0){
      e.x += dx;
      const minX = e.x - e.w/2, maxX = e.x + e.w/2;
      const minY = e.y - e.h/2, maxY = e.y + e.h/2;
      const tiles = getSolidTilesInAABB(minX, minY, maxX, maxY);
      for(const t of tiles){
        const tx = t.gx*TILE, ty = t.gy*TILE;
        const tminX = tx, tmaxX = tx+TILE;
        const tminY = ty, tmaxY = ty+TILE;
        if(maxY<=tminY || minY>=tmaxY || maxX<=tminX || minX>=tmaxX) continue;
        if(dx > 0){
          e.x = tminX - e.w/2;
          e.vx = 0;
        } else {
          e.x = tmaxX + e.w/2;
          e.vx = 0;
        }
        break;
      }
    }

    let hitGround = false;
    if(dy !== 0){
      e.y += dy;
      const minX = e.x - e.w/2, maxX = e.x + e.w/2;
      const minY = e.y - e.h/2, maxY = e.y + e.h/2;
      const tiles = getSolidTilesInAABB(minX, minY, maxX, maxY);
      for(const t of tiles){
        const tx = t.gx*TILE, ty = t.gy*TILE;
        const tminX = tx, tmaxX = tx+TILE;
        const tminY = ty, tmaxY = ty+TILE;
        if(maxY<=tminY || minY>=tmaxY || maxX<=tminX || minX>=tmaxX) continue;
        if(dy > 0){
          e.y = tminY - e.h/2;
          e.vy = 0;
          hitGround = true;
        } else {
          e.y = tmaxY + e.h/2;
          e.vy = 0;
        }
        break;
      }
    }
    return hitGround;
  }

  // ===== PARTICLES =====
  function puff(x, y){
    for(let i=0; i<3; i++){
      particles.push({
        x: x + (Math.random()*6-3),
        y: y + (Math.random()*4-2),
        vx: (Math.random()*60-30),
        vy: -(40 + Math.random()*40),
        r: 4 + Math.random()*3,
        a: 0.9
      });
    }
  }

  function updateParticles(dt){
    for(let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 40 * dt;
      p.a -= 0.6 * dt;
      p.r += 8 * dt;
      if(p.a <= 0) particles.splice(i, 1);
    }
  }

  function drawParticles(){
    cx.save();
    cx.globalAlpha = 1;
    for(const p of particles){
      cx.fillStyle = `rgba(229,223,212,${Math.max(0,p.a)})`;
      cx.beginPath();
      cx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      cx.fill();
    }
    cx.restore();
  }

  // ===== INPUT =====
  addEventListener('keydown', (e) => {
    if(['ArrowLeft','ArrowRight','ArrowUp','Space','KeyA','KeyD','KeyW','KeyR','Escape'].includes(e.code)){
      e.preventDefault();
    }
    keys.add(e.code);
  });
  addEventListener('keyup', (e) => keys.delete(e.code));

  const press = (el, set) => {
    if(!el) return;
    const on = () => set(true);
    const off = () => set(false);
    el.addEventListener('touchstart', e => { e.preventDefault(); on(); }, {passive:false});
    el.addEventListener('touchend', off);
    el.addEventListener('mousedown', on);
    el.addEventListener('mouseup', off);
    el.addEventListener('mouseleave', off);
  };

  press(BTN.left, v => mLeft=v);
  press(BTN.right, v => mRight=v);
  press(BTN.jump, v => mJump=v);
  BTN.restart?.addEventListener('click', reset);
  BTN.menuBtn?.addEventListener('click', showMenu);

  // ===== GAME LOOP =====
  let acc = 0, last = performance.now();
  const STEP = 1/60;

  function frame(now){
    if(!gameRunning){
      requestAnimationFrame(frame);
      return;
    }

    let dt = Math.min(0.25, (now - last) / 1000);
    last = now;
    acc += dt;

    while(acc >= STEP){
      update(STEP);
      acc -= STEP;
    }

    draw();
    requestAnimationFrame(frame);
  }

  function update(dt){
    const left = keys.has('ArrowLeft') || keys.has('KeyA') || mLeft;
    const right = keys.has('ArrowRight') || keys.has('KeyD') || mRight;
    const jumpKey = keys.has('Space') || keys.has('ArrowUp') || keys.has('KeyW') || mJump;
    if(keys.has('KeyR')) reset();
    if(keys.has('Escape')) showMenu();

    // Movement
    const target = (right - left) * RUN_SPEED;
    const accel = player.onGround ? ACCEL_GROUND : ACCEL_AIR;
    const diff = target - player.vx;
    const step = Math.sign(diff) * accel * dt;
    if(Math.abs(step) > Math.abs(diff)) player.vx = target;
    else player.vx += step;

    if(!left && !right && player.onGround){
      const f = Math.min(Math.abs(player.vx), FRICTION*dt);
      player.vx -= Math.sign(player.vx) * f;
    }

    // Gravity & Jump
    player.vy += GRAVITY * dt;
    if(player.vy > MAX_FALL) player.vy = MAX_FALL;

    player.coyote = player.onGround ? COYOTE : Math.max(0, player.coyote - dt);
    player.jumpBuf = jumpKey ? JUMP_BUFFER : Math.max(0, player.jumpBuf - dt);

    if(player.jumpBuf > 0 && player.coyote > 0){
      player.vy = -JUMP_VEL;
      player.onGround = false;
      player.coyote = 0;
      player.jumpBuf = 0;
      puff(player.x, player.y + player.h/2);
    }

    // Integrate
    moveAndCollide(player, player.vx * dt, 0);
    const grounded = moveAndCollide(player, 0, player.vy * dt);
    if(grounded && !player.onGround && player.vy >= 200){
      puff(player.x, player.y + player.h/2);
    }
    player.onGround = grounded;
    player.anim += dt * (player.onGround ? (Math.abs(player.vx)>10 ? 8 : 4) : 6);

    // Fall death
    if(player.y > world.h + 200) loseLife();

    // Coins
    for(const c of coins){
      if(!c.alive) continue;
      c.t += dt * 6;
      const dx = Math.abs(player.x - c.x);
      const dy = Math.abs(player.y - c.y);
      if(dx < (player.w/2 + c.r) && dy < (player.h/2 + c.r)){
        c.alive = false;
        player.coins++;
        HUD.coins.textContent = player.coins;
      }
    }

    // Enemies
    for(const e of enemies){
      if(!e.alive) continue;
      e.x += e.vx * dt;

      const aheadX = e.x + Math.sign(e.vx) * (e.w/2 + 2);
      const feetY = e.y + e.h/2 + 1;
      const hitWall = solidAtWorld(aheadX, e.y);
      const noFloor = !solidAtWorld(aheadX, feetY);
      if(hitWall || noFloor) e.vx *= -1;

      const dx = Math.abs(player.x - e.x);
      const dy = Math.abs(player.y - e.y);
      const hit = dx < (player.w/2 + e.w/2) && dy < (player.h/2 + e.h/2);
      if(hit){
        if(player.vy > 120){
          e.alive = false;
          player.vy = -JUMP_VEL * 0.6;
          puff(e.x, e.y + e.h/2);
        } else if(player.inv <= 0){
          damage();
        }
      }
    }

    // Goal
    const goal = findGoalCenter();
    if(goal && Math.hypot(player.x - goal.x, player.y - goal.y) < 34){
      win();
    }

    // Camera
    const look = Math.sign(player.vx) * 90;
    const targetX = clamp(player.x - canvas.width/2 + look, 0, world.w - canvas.width);
    camera.x += (targetX - camera.x) * CAMERA_LERP;
    camera.y = 0;

    if(player.inv > 0) player.inv -= dt;
    updateParticles(dt);
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function findGoalCenter(){
    for(let y=0; y<ROWS; y++){
      const x = LEVEL[y].indexOf('G');
      if(x !== -1) return {x: (x+0.5)*TILE, y: (y+0.5)*TILE};
    }
    return null;
  }

  function damage(){
    player.inv = 1.1;
    player.lives--;
    HUD.lives.textContent = player.lives;
    if(player.lives < 0){
      showBanner('ðŸ’€ Verloren! DrÃ¼cke R fÃ¼r Neustart');
      setTimeout(reset, 2000);
    } else {
      player.vy = -JUMP_VEL * 0.55;
    }
  }

  function loseLife(){
    player.lives--;
    HUD.lives.textContent = player.lives;
    if(player.lives < 0){
      showBanner('ðŸ’€ Game Over! DrÃ¼cke R');
      setTimeout(reset, 2000);
    } else {
      player.x = (playerStart.x + 0.2) * TILE;
      player.y = (playerStart.y - 0.25) * TILE;
      player.vx = 0;
      player.vy = 0;
    }
  }

  function showBanner(msg){ bannerMsg = msg; bannerT = 2.6; }

  function win(){
    const perfect = player.coins === coins.length;
    const msg = perfect
      ? 'ðŸŒŸ Perfekt! Alle ' + coins.length + ' MÃ¼nzen!'
      : 'âœ“ Geschafft! MÃ¼nzen: ' + player.coins + '/' + coins.length;
    showBanner(msg);
    setTimeout(nextLevel, 2000);
  }

  // ===== RENDERING =====
  function draw(){
    cx.save();
    cx.clearRect(0, 0, canvas.width, canvas.height);
    drawParallax();
    cx.translate(-camera.x, -camera.y);

    // Tiles
    for(let y=0; y<ROWS; y++){
      for(let x=0; x<COLS; x++){
        const c = LEVEL[y][x];
        const px = x * TILE, py = y * TILE;
        if(c==='#' || c==='@') drawTile(px, py, c);
        if(c==='G') drawGoal(px, py);
      }
    }

    // Coins
    for(const c of coins){
      if(!c.alive) continue;
      const bob = Math.sin(c.t) * 3;
      cx.fillStyle = getVar('--coin');
      cx.beginPath();
      cx.arc(c.x, c.y + bob, c.r, 0, Math.PI*2);
      cx.fill();
      cx.fillStyle = 'rgba(0,0,0,0.12)';
      cx.fillRect(c.x - c.r, c.y + bob + c.r - 3, c.r*2, 3);
      cx.fillStyle = 'rgba(255,255,255,0.27)';
      cx.beginPath();
      cx.arc(c.x + 4, c.y - 4 + bob, c.r * 0.5, 0, Math.PI*2);
      cx.fill();
    }

    // Enemies
    for(const e of enemies){
      if(!e.alive) continue;
      cx.fillStyle = getVar('--enemy');
      roundRect(cx, e.x - e.w/2, e.y - e.h/2, e.w, e.h, 6, true, false);
      cx.fillStyle = 'rgba(0,0,0,0.18)';
      cx.fillRect(e.x - e.w/2, e.y - e.h/2, e.w, 5);
    }

    // Player
    drawClipper(player.x, player.y, player);
    drawParticles();

    // Banner
    if(bannerT > 0){
      bannerT -= 1/60;
      cx.resetTransform();
      cx.fillStyle = 'rgba(0,0,0,0.7)';
      const bw = canvas.width * 0.8, bh = 70;
      const bx = canvas.width/2 - bw/2;
      const by = canvas.height * 0.3;
      roundRect(cx, bx, by, bw, bh, 12, true, false);
      cx.strokeStyle = 'rgba(255,255,255,0.3)';
      cx.lineWidth = 2;
      roundRect(cx, bx, by, bw, bh, 12, false, true);
      cx.fillStyle = '#e5f1ff';
      cx.font = 'bold 22px ui-sans-serif, system-ui';
      cx.textAlign = 'center';
      cx.textBaseline = 'middle';
      cx.fillText(bannerMsg, canvas.width/2, by + bh/2);
    }

    cx.restore();
  }

  function getVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name);
  }

  function drawTile(x, y, c){
    const dirt = '#5a3c28';
    const grass = getVar('--grass');
    const stone = '#6b7280';
    cx.fillStyle = (c === '#') ? dirt : stone;
    cx.fillRect(x, y, TILE, TILE);
    cx.fillStyle = 'rgba(0,0,0,0.08)';
    for(let i=0; i<4; i++){
      cx.fillRect(x + Math.random()*TILE, y + Math.random()*TILE, 2, 2);
    }
    if(c === '#'){
      cx.fillStyle = grass;
      cx.fillRect(x, y, TILE, 8);
      cx.fillStyle = 'rgba(0,0,0,0.25)';
      cx.fillRect(x, y+8, TILE, 2);
    } else {
      cx.fillStyle = 'rgba(255,255,255,0.15)';
      cx.fillRect(x, y, TILE, 6);
    }
  }

  function drawGoal(x, y){
    cx.fillStyle = '#d1d5db';
    cx.fillRect(x + TILE*0.78, y + TILE*0.1, 4, TILE*0.8);
    cx.fillStyle = getVar('--flag');
    cx.beginPath();
    cx.moveTo(x + TILE*0.78 + 4, y + TILE*0.12);
    cx.lineTo(x + TILE*0.78 + 4 + TILE*0.36, y + TILE*0.18);
    cx.lineTo(x + TILE*0.78 + 4, y + TILE*0.24);
    cx.closePath();
    cx.fill();
    cx.fillStyle = getVar('--goal');
    cx.fillRect(x + TILE*0.18, y + TILE*0.2, TILE*0.42, TILE*0.6);
  }

  function drawClipper(cxX, cyY, p){
    const t = p.anim;
    const running = Math.abs(p.vx) > 10 && p.onGround;
    const jumping = !p.onGround;
    const bob = running ? Math.sin(t)*1.5 : Math.sin(t*0.5)*1.2;
    const x = cxX - p.w/2;
    const y = cyY - p.h/2 + bob;
    const w = p.w, h = p.h;

    cx.save();
    if(p.inv > 0 && Math.floor(t*20) % 2 === 0){
      cx.globalAlpha = 0.5;
    }

    // Body
    cx.fillStyle = getVar('--clipper');
    roundRect(cx, x, y, w, h, 6, true, false);

    // Metal cap
    cx.fillStyle = getVar('--clipper-dark');
    roundRect(cx, x, y-6, w, 12, 6, true, false);

    // Wheel
    cx.fillStyle = '#6e7077';
    cx.beginPath();
    cx.arc(x + w - 4, y - 4, 6, Math.PI*0.2, Math.PI*1.2);
    cx.fill();

    // Flame when jumping
    if(jumping && p.vy < -100){
      cx.fillStyle = '#ffdd55';
      cx.beginPath();
      cx.moveTo(x + w - 6, y - 10);
      cx.quadraticCurveTo(x + w + 6, y - 18, x + w - 4, y - 28);
      cx.quadraticCurveTo(x + w - 12, y - 18, x + w - 6, y - 10);
      cx.fill();
    }

    // Face
    cx.fillStyle = '#2b2f37';
    // Eyes
    cx.beginPath();
    cx.ellipse(x + w*0.35, y + h*0.42, 2.8, 4.2, 0, 0, Math.PI*2);
    cx.fill();
    cx.beginPath();
    cx.ellipse(x + w*0.62, y + h*0.44, 2.8, 4.2, 0, 0, Math.PI*2);
    cx.fill();

    // Mouth
    cx.lineWidth = 1.5;
    cx.beginPath();
    cx.moveTo(x + w*0.30, y + h*0.62);
    cx.quadraticCurveTo(x + w*0.52, y + h*0.72, x + w*0.74, y + h*0.60);
    cx.strokeStyle = '#2b2f37';
    cx.stroke();

    // Arms & Legs
    cx.fillStyle = '#2b2f37';
    roundRect(cx, x-6, y + h*0.45, 6, 10, 3, true, false);
    roundRect(cx, x+w, y + h*0.45, 6, 10, 3, true, false);
    roundRect(cx, x + w*0.15, y + h - 6, 6, 10, 3, true, false);
    roundRect(cx, x + w*0.65, y + h - 6, 6, 10, 3, true, false);

    // Shine
    cx.globalAlpha = 0.18;
    roundRect(cx, x+1, y+1, w-2, 6, 4, true, false);

    cx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  function drawParallax(){
    cx.save();
    const bands = [
      {y:120, a:0.15, col:'rgba(255,255,255,0.03)'},
      {y:220, a:0.25, col:'rgba(255,255,255,0.04)'}
    ];
    for(const b of bands){
      cx.fillStyle = b.col;
      const offs = -(camera.x * b.a % 240);
      for(let i=-1; i<8; i++){
        cx.fillRect(offs + i*240, b.y, 240, 2);
      }
    }
    cx.translate(-(camera.x*0.25) % 480, 0);
    const hill = (x, y, w, h) => {
      cx.beginPath();
      cx.moveTo(x, y+h);
      cx.quadraticCurveTo(x + w*0.25, y, x + w*0.5, y + h*0.4);
      cx.quadraticCurveTo(x + w*0.75, y + h*0.8, x+w, y+h);
      cx.closePath();
    };
    cx.fillStyle = 'rgba(46,66,113,0.30)';
    for(let i=-1; i<6; i++){
      hill(i*480, 360, 480, 140);
      cx.fill();
    }
    cx.restore();
  }

  // ===== CANVAS RESIZE =====
  function resizeCanvas(){
    const maxW = 960;
    const ratio = 16/9;
    const w = Math.min(window.innerWidth, maxW);
    const h = w / ratio;
    canvas.width = w;
    canvas.height = h;
  }

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // ===== START =====
  initMenu();
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
