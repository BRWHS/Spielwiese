<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clipper Run - Complete Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        body {
            background: linear-gradient(to bottom, #5c94fc, #8fb4fc);
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameCanvas {
            border: 3px solid #2c3e50;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: #87ceeb;
            cursor: pointer;
            max-width: 100%;
            max-height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-size: 14px;
            z-index: 100;
        }
        
        .ui-item {
            margin-bottom: 10px;
        }
        
        #menu {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        #menu.hidden {
            display: none;
        }
        
        h1 {
            color: #ffd700;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 4px 4px 0 #000;
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        
        .menu-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: 3px solid #fff;
            padding: 15px 40px;
            margin: 10px;
            font-size: 16px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 0 #2c3e50;
        }
        
        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 0 #2c3e50;
        }
        
        .menu-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #2c3e50;
        }
        
        #controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            text-shadow: 2px 2px 0 #000;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="menu">
        <h1>CLIPPER RUN</h1>
        <p style="color: white; margin-bottom: 30px; text-shadow: 2px 2px 0 #000;">
            The Ultimate Pixel Adventure
        </p>
        <button class="menu-btn" onclick="startGame(1)">Easy Level</button>
        <button class="menu-btn" onclick="startGame(2)">Medium Level</button>
        <button class="menu-btn" onclick="startGame(3)">Hard Level</button>
        <div id="controls-info">
            <p>‚¨ÖÔ∏è‚û°Ô∏è Move | SPACE Jump | SHIFT Run</p>
        </div>
    </div>
    
    <div id="ui" style="display: none;">
        <div class="ui-item">‚ù§Ô∏è Lives: <span id="lives">3</span></div>
        <div class="ui-item">ü™ô Coins: <span id="coins">0</span></div>
        <div class="ui-item">üìä Score: <span id="score">0</span></div>
        <div class="ui-item">‚è±Ô∏è Time: <span id="time">0</span>s</div>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas setup
        canvas.width = 1024;
        canvas.height = 576;
        ctx.imageSmoothingEnabled = false;
        
        // Game variables
        let gameRunning = false;
        let currentLevel = 1;
        let gameTime = 0;
        let lastTime = 0;
        
        // Game objects
        let player = null;
        let enemies = [];
        let coins = [];
        let platforms = [];
        let particles = [];
        let camera = { x: 0, y: 0 };
        
        // Input
        const keys = {};
        
        // Constants
        const GRAVITY = 1200;
        const PLAYER_SPEED = 300;
        const PLAYER_RUN_SPEED = 450;
        const JUMP_FORCE = 500;
        const TILE_SIZE = 32;
        
        // Level maps
        const LEVELS = {
            1: {
                name: "Grassland",
                map: [
                    "                                                ",
                    "                  ***                          ",
                    "                           ***                 ",
                    "        ***                      ***         G ",
                    "                  ####                    ######",
                    "      P      ###        ###    E               ",
                    "    ####                    ######             ",
                    "              E                      ###       ",
                    "################################################"
                ]
            },
            2: {
                name: "Cave",
                map: [
                    "################################################",
                    "#              ***         ***                #",
                    "#                                    ***      #",
                    "#  P     ###         E         ###         G  #",
                    "####              ######                  #####",
                    "#      ***                        ***          #",
                    "#            E            E                    #",
                    "#   ####        ####        ####        ####  #",
                    "################################################"
                ]
            },
            3: {
                name: "Sky Challenge",
                map: [
                    "                                                ",
                    "     ***                ***            ***     ",
                    "                                              G ",
                    " P         ##      ##        ##      ##    ####",
                    "###                                             ",
                    "        E       E       E        E        E     ",
                    "     ###    ###    ###    ###    ###    ###    ",
                    "                                                ",
                    "                                                "
                ]
            }
        };
        
        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = 28;
                this.height = 36;
                this.onGround = false;
                this.facing = 1;
                this.lives = 3;
                this.coins = 0;
                this.score = 0;
                this.invulnerable = 0;
                this.animFrame = 0;
            }
            
            update(dt) {
                // Input handling
                if (keys['ArrowLeft'] || keys['a']) {
                    this.vx = keys['Shift'] ? -PLAYER_RUN_SPEED : -PLAYER_SPEED;
                    this.facing = -1;
                } else if (keys['ArrowRight'] || keys['d']) {
                    this.vx = keys['Shift'] ? PLAYER_RUN_SPEED : PLAYER_SPEED;
                    this.facing = 1;
                } else {
                    this.vx *= 0.85;
                }
                
                // Jump
                if ((keys[' '] || keys['ArrowUp'] || keys['w']) && this.onGround) {
                    this.vy = -JUMP_FORCE;
                    this.onGround = false;
                    createJumpParticles(this.x + this.width/2, this.y + this.height);
                }
                
                // Gravity
                if (!this.onGround) {
                    this.vy += GRAVITY * dt;
                    if (this.vy > 800) this.vy = 800;
                }
                
                // Apply movement
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                // Update animation
                this.animFrame += dt * 10;
                
                // Update invulnerability
                if (this.invulnerable > 0) {
                    this.invulnerable -= dt;
                }
            }
            
            draw() {
                if (this.invulnerable > 0 && Math.floor(this.invulnerable * 10) % 2 === 0) {
                    return; // Flash effect
                }
                
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                if (this.facing < 0) {
                    ctx.scale(-1, 1);
                }
                
                // Draw Clipper character
                const bobOffset = Math.sin(this.animFrame) * 2;
                
                // Body
                ctx.fillStyle = '#d9dbdf';
                ctx.fillRect(-14, -18 + bobOffset, 28, 34);
                
                // Top metal part
                ctx.fillStyle = '#8a8f97';
                ctx.fillRect(-14, -18 + bobOffset, 28, 10);
                
                // Wheel
                ctx.fillStyle = '#2a2f37';
                ctx.beginPath();
                ctx.arc(10, -13 + bobOffset, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Label
                ctx.fillStyle = '#2b2f37';
                ctx.fillRect(-12, -6 + bobOffset, 24, 12);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 6px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('CLIPPER', 0, 1 + bobOffset);
                
                // Face
                ctx.fillStyle = '#1a1d23';
                ctx.beginPath();
                ctx.arc(-5, 6 + bobOffset, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(5, 6 + bobOffset, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Smile
                ctx.strokeStyle = '#1a1d23';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(0, 8 + bobOffset, 6, 0.25 * Math.PI, 0.75 * Math.PI);
                ctx.stroke();
                
                // Arms and legs
                ctx.fillStyle = '#2b2f37';
                const walkOffset = Math.abs(this.vx) > 50 ? Math.sin(this.animFrame * 2) * 5 : 0;
                ctx.fillRect(-18, 2 + bobOffset, 5, 10);
                ctx.fillRect(13, 2 + bobOffset, 5, 10);
                ctx.fillRect(-8 + walkOffset, 16, 5, 8);
                ctx.fillRect(3 - walkOffset, 16, 5, 8);
                
                ctx.restore();
            }
        }
        
        // Enemy class
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 80;
                this.width = 28;
                this.height = 36;
                this.startX = x;
                this.alive = true;
                this.animFrame = 0;
            }
            
            update(dt) {
                if (!this.alive) return;
                
                this.x += this.vx * dt;
                this.animFrame += dt * 10;
                
                // Patrol back and forth
                if (Math.abs(this.x - this.startX) > 100) {
                    this.vx = -this.vx;
                }
            }
            
            draw() {
                if (!this.alive) return;
                
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                
                // Draw Lighter enemy
                const bobOffset = Math.sin(this.animFrame) * 2;
                
                // Body (dark)
                ctx.fillStyle = '#4a4f57';
                ctx.fillRect(-14, -18 + bobOffset, 28, 34);
                
                // Top part
                ctx.fillStyle = '#1a1f27';
                ctx.fillRect(-14, -18 + bobOffset, 28, 10);
                
                // Evil wheel
                ctx.fillStyle = '#8b1a1a';
                ctx.beginPath();
                ctx.arc(10, -13 + bobOffset, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Label
                ctx.fillStyle = '#1a1f27';
                ctx.fillRect(-12, -6 + bobOffset, 24, 12);
                ctx.fillStyle = '#ff6b6b';
                ctx.font = 'bold 5px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('LIGHTER', 0, 1 + bobOffset);
                
                // Evil eyes
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(-9, 4 + bobOffset);
                ctx.lineTo(-4, 7 + bobOffset);
                ctx.lineTo(-9, 10 + bobOffset);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(9, 4 + bobOffset);
                ctx.lineTo(4, 7 + bobOffset);
                ctx.lineTo(9, 10 + bobOffset);
                ctx.fill();
                
                // Evil grin
                ctx.fillStyle = '#1a1f27';
                ctx.fillRect(-8, 11 + bobOffset, 16, 6);
                ctx.fillStyle = '#ffffff';
                for (let i = -2; i <= 2; i++) {
                    ctx.fillRect(i * 3 - 1, 12 + bobOffset, 2, 3);
                }
                
                // Arms and legs
                ctx.fillStyle = '#1a1f27';
                ctx.fillRect(-18, 0 + bobOffset, 6, 12);
                ctx.fillRect(12, 0 + bobOffset, 6, 12);
                ctx.fillRect(-8, 16, 5, 8);
                ctx.fillRect(3, 16, 5, 8);
                
                ctx.restore();
            }
        }
        
        // Particle system
        function createJumpParticles(x, y) {
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y,
                    vx: (Math.random() - 0.5) * 100,
                    vy: -Math.random() * 100,
                    life: 0.5,
                    color: '#8a8f97'
                });
            }
        }
        
        function createCoinParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * 200,
                    vy: Math.sin(angle) * 200 - 100,
                    life: 0.8,
                    color: '#ffd700'
                });
            }
        }
        
        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 500 * dt;
                p.life -= dt;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
            });
            ctx.globalAlpha = 1;
        }
        
        // Load level
        function loadLevel(levelNum) {
            const level = LEVELS[levelNum];
            if (!level) return;
            
            platforms = [];
            enemies = [];
            coins = [];
            
            for (let y = 0; y < level.map.length; y++) {
                for (let x = 0; x < level.map[y].length; x++) {
                    const char = level.map[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;
                    
                    switch(char) {
                        case '#':
                            platforms.push({
                                x: px,
                                y: py,
                                width: TILE_SIZE,
                                height: TILE_SIZE
                            });
                            break;
                        case 'P':
                            player = new Player(px, py);
                            break;
                        case 'E':
                            enemies.push(new Enemy(px, py));
                            break;
                        case '*':
                            coins.push({
                                x: px + TILE_SIZE/2,
                                y: py + TILE_SIZE/2,
                                collected: false
                            });
                            break;
                        case 'G':
                            platforms.push({
                                x: px,
                                y: py,
                                width: TILE_SIZE,
                                height: TILE_SIZE,
                                isGoal: true
                            });
                            break;
                    }
                }
            }
        }
        
        // Collision detection
        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }
        
        // Game update
        function update(dt) {
            if (!gameRunning || !player) return;
            
            gameTime += dt;
            
            // Update player
            player.update(dt);
            
            // Platform collisions
            player.onGround = false;
            platforms.forEach(platform => {
                if (checkCollision(player, platform)) {
                    if (platform.isGoal) {
                        // Win!
                        alert(`Level Complete!\nScore: ${player.score}\nTime: ${Math.floor(gameTime)}s`);
                        showMenu();
                        return;
                    }
                    
                    // Land on platform
                    if (player.vy > 0 && player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                    }
                }
            });
            
            // Collect coins
            coins.forEach(coin => {
                if (coin.collected) return;
                
                const dx = Math.abs(player.x + player.width/2 - coin.x);
                const dy = Math.abs(player.y + player.height/2 - coin.y);
                
                if (dx < 20 && dy < 20) {
                    coin.collected = true;
                    player.coins++;
                    player.score += 10;
                    createCoinParticles(coin.x, coin.y);
                    updateUI();
                }
            });
            
            // Enemy collisions
            enemies.forEach(enemy => {
                if (!enemy.alive) return;
                
                enemy.update(dt);
                
                if (checkCollision(player, enemy)) {
                    if (player.vy > 100 && player.y < enemy.y) {
                        // Stomp enemy
                        enemy.alive = false;
                        player.vy = -300;
                        player.score += 50;
                        updateUI();
                    } else if (player.invulnerable <= 0) {
                        // Take damage
                        player.lives--;
                        player.invulnerable = 2;
                        updateUI();
                        
                        if (player.lives <= 0) {
                            alert('Game Over!');
                            showMenu();
                        }
                    }
                }
            });
            
            // Update particles
            updateParticles(dt);
            
            // Update camera
            camera.x = player.x - canvas.width/2;
            camera.y = player.y - canvas.height/2;
            camera.x = Math.max(0, Math.min(camera.x, LEVELS[currentLevel].map[0].length * TILE_SIZE - canvas.width));
            camera.y = Math.max(0, Math.min(camera.y, LEVELS[currentLevel].map.length * TILE_SIZE - canvas.height));
            
            // Fall death
            if (player.y > LEVELS[currentLevel].map.length * TILE_SIZE + 100) {
                player.lives = 0;
                alert('Game Over - Fell off the map!');
                showMenu();
            }
        }
        
        // Render
        function render() {
            // Clear
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw clouds
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            for (let i = 0; i < 3; i++) {
                const x = (i * 300 - camera.x * 0.3) % (canvas.width + 100);
                ctx.beginPath();
                ctx.arc(x, 100, 40, 0, Math.PI * 2);
                ctx.arc(x + 30, 100, 45, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            
            // Draw platforms
            platforms.forEach(platform => {
                if (platform.isGoal) {
                    // Goal
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    ctx.fillStyle = '#fff';
                    ctx.font = '20px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('üèÅ', platform.x + platform.width/2, platform.y + platform.height/2 + 8);
                } else {
                    // Normal platform
                    ctx.fillStyle = '#8b6239';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    ctx.fillStyle = '#52d053';
                    ctx.fillRect(platform.x, platform.y, platform.width, 8);
                }
            });
            
            // Draw coins
            coins.forEach((coin, i) => {
                if (coin.collected) return;
                
                const bob = Math.sin(gameTime * 3 + i) * 5;
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(coin.x, coin.y + bob, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffed4e';
                ctx.beginPath();
                ctx.arc(coin.x, coin.y + bob, 7, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw enemies
            enemies.forEach(enemy => enemy.draw());
            
            // Draw particles
            drawParticles();
            
            // Draw player
            if (player) player.draw();
            
            ctx.restore();
        }
        
        // Game loop
        function gameLoop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            update(dt);
            render();
            
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        // UI
        function updateUI() {
            document.getElementById('lives').textContent = player.lives;
            document.getElementById('coins').textContent = player.coins;
            document.getElementById('score').textContent = player.score;
            document.getElementById('time').textContent = Math.floor(gameTime);
        }
        
        // Start game
        function startGame(level) {
            currentLevel = level;
            gameTime = 0;
            particles = [];
            
            loadLevel(level);
            
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('ui').style.display = 'block';
            
            gameRunning = true;
            lastTime = performance.now();
            updateUI();
            gameLoop(performance.now());
        }
        
        // Show menu
        function showMenu() {
            gameRunning = false;
            document.getElementById('menu').classList.remove('hidden');
            document.getElementById('ui').style.display = 'none';
        }
        
        // Input handling
        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key === 'Escape') showMenu();
        });
        
        document.addEventListener('keyup', e => {
            keys[e.key] = false;
        });
    </script>
</body>
</html>
